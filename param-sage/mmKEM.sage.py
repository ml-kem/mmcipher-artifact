

# This file was *autogenerated* from the file mmKEM.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_12 = Integer(12); _sage_const_128 = Integer(128); _sage_const_1p0045 = RealNumber('1.0045'); _sage_const_192 = Integer(192); _sage_const_1p0029 = RealNumber('1.0029'); _sage_const_256 = Integer(256); _sage_const_1p0023 = RealNumber('1.0023'); _sage_const_3 = Integer(3); _sage_const_24 = Integer(24); _sage_const_10 = Integer(10); _sage_const_129 = Integer(129); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_8 = Integer(8); _sage_const_1024 = Integer(1024); _sage_const_768 = Integer(768)
load("https://bitbucket.org/malb/lwe-estimator/raw/HEAD/estimator.py")

def findMLWEdelta(bar_nu, n, d, logq):
    n = n * d
    q = _sage_const_2 **logq
    stddev = float(sqrt((bar_nu**_sage_const_2  - _sage_const_1 )/_sage_const_12 ))
    alpha = alphaf(sigmaf(stddev),q)
    set_verbose(_sage_const_1 )
    L = estimate_lwe(n, alpha, q, reduction_cost_model=BKZ.enum)
    delta_enum1 = L['usvp']['delta_0']
    delta_enum2 = L['dec']['delta_0']
    delta_enum3 = L['dual']['delta_0']
    L = estimate_lwe(n, alpha, q, reduction_cost_model=BKZ.sieve)
    delta_sieve1 = L['usvp']['delta_0']
    delta_sieve2 = L['dec']['delta_0']
    delta_sieve3 = L['dual']['delta_0']
    return max(delta_enum1,delta_enum2,delta_enum3,delta_sieve1,delta_sieve2,delta_sieve3)


def find_MLWE_n(nu, d, logq, sec):
    mlwe =  _sage_const_1                                # dimension of the Module-LWE problem
    mlwe_hardness = _sage_const_2 
    # 128-bit security: 1.0045
    # 192-bit security: 1.0029
    # 256-bit security: 1.0023
    if sec == _sage_const_128 :
        while mlwe_hardness > _sage_const_1p0045 :           # increasing the mlwe dimension until MLWE provides ~ 128-bit security
            mlwe += _sage_const_1 
            mlwe_hardness = findMLWEdelta(nu,mlwe,d, logq)
    if sec == _sage_const_192 :
        while mlwe_hardness > _sage_const_1p0029 :           # increasing the mlwe dimension until MLWE provides ~ 192-bit security
            mlwe += _sage_const_1 
            mlwe_hardness = findMLWEdelta(nu,mlwe,d, logq)
    if sec == _sage_const_256 :
        while mlwe_hardness > _sage_const_1p0023 :           # increasing the mlwe dimension until MLWE provides ~ 192-bit security
            mlwe += _sage_const_1 
            mlwe_hardness = findMLWEdelta(nu,mlwe,d, logq)
    return mlwe

def find_sigma(d, m, n):
   return sqrt(_sage_const_2 ) * sqrt( ln(_sage_const_2  * (d * (m + n)) * (_sage_const_1  + _sage_const_2 **(_sage_const_1 +_sage_const_128 ))) / pi)

d = _sage_const_256 
nu = _sage_const_1 
bar_nu = _sage_const_3 
sec = _sage_const_128 

logq = _sage_const_24 


ell = _sage_const_2 **_sage_const_10 
d_v = _sage_const_1 


tau = sqrt(-log(_sage_const_2 **(-_sage_const_129 ))/pi)


flag = _sage_const_0 
while flag == _sage_const_0 :
    n = find_MLWE_n(bar_nu, d, logq, sec)
    m = n
    sigma = find_sigma(d, m, n)
    sigma_1 = _sage_const_2  * sqrt(sigma**_sage_const_2  + _sage_const_1 )

    B = ell * (n+m) * (d * nu)**_sage_const_2 

    sigma_2 = _sage_const_2  * sqrt(B) * sqrt(sigma**_sage_const_2  + _sage_const_1 )
    d_u = logq
    dec_error = _sage_const_2 *((n+m) * d * nu * sigma_1 * tau + sigma_2 * tau + round(_sage_const_2 **logq / _sage_const_2 **(d_u + _sage_const_1 )) )+ _sage_const_1 
    if dec_error < _sage_const_2 **logq / _sage_const_4  :
        flag = _sage_const_1 
        print("sec level = ", sec)
        print("mmKEM: N = ", ell)
        print("mmKEM: logq = ", logq)
        print("mmKEM: n = ", n)
        print("mmKEM: public parameter |pp| size (KB) = ", round((float(d*logq*n**_sage_const_2 )/_sage_const_8 /_sage_const_1024 ),_sage_const_3 ))
        print("mmKEM: public key |pk| size (KB) = ", round((float(d*logq*n)/_sage_const_8 /_sage_const_1024 ),_sage_const_3 ))

        d_u = _sage_const_0 
        dec_error_1 = ((n+m) * d * nu * sigma_1 * tau + sigma_2 * tau + nu * d * n * round(_sage_const_2 **logq / _sage_const_2 **(d_u + _sage_const_1 )) + round(_sage_const_2 **logq / _sage_const_2 **(d_u + _sage_const_1 )) )*_sage_const_2  + _sage_const_1 
        while dec_error_1 >= _sage_const_2 **logq / _sage_const_4  and d_u <= logq:
            d_u = d_u + _sage_const_1 
            dec_error_1 = ((n+m) * d * nu * sigma_1 * tau + sigma_2 * tau + nu * d * n * round(_sage_const_2 **logq / _sage_const_2 **(d_u + _sage_const_1 )) + round(_sage_const_2 **logq / _sage_const_2 **(d_u + _sage_const_1 )) )*_sage_const_2  + _sage_const_1 
        print("d_u = ", d_u)
        print("mmKEM: |ct_0| (KB) = ", round((float(d*d_u*(n))/_sage_const_8 /_sage_const_1024 ), _sage_const_3 ))
        print("mmKEM: |ct_i| (KB) = ", round((float(d*d_v)/_sage_const_8 /_sage_const_1024 ), _sage_const_3 ))
        print("mmKEM: total |ct| (KB) = ", round((float(d*d_v*ell + d*d_u*(n))/_sage_const_8 /_sage_const_1024 ), _sage_const_3 ))
        print("mmKEM-comp: compress rate k = ", round(float(ell * _sage_const_768 *_sage_const_8 * sec/_sage_const_128 )/float(d*d_u*n + d*d_v*ell),_sage_const_3 ) )


    else:
        logq = logq + _sage_const_1 
        print("logq = ", logq)

find_prime = _sage_const_0 
q = _sage_const_2 **logq
q = q + _sage_const_1 
while find_prime == _sage_const_0 :
    if is_prime(q) == True:
        find_prime = _sage_const_1 
        print("prime q = ", q)
        print("[log q] = ", round(log(q, _sage_const_2 ),_sage_const_3 ))
        if dec_error >= _sage_const_2 **logq / _sage_const_4 :
            print("!!!!! q fail")
    q = q - _sage_const_2 **_sage_const_8 


print("Gaussian width sigma_0 = ", round(sigma_1, _sage_const_3 ))
print("Gaussian width sigma_1 = ", round(sigma_2, _sage_const_3 ))
print("Standard deviation s_0 = ", round(sigma_1/sqrt(_sage_const_2 *pi), _sage_const_3 ))
print("Standard deviation s_1 = ", round(sigma_2/sqrt(_sage_const_2 *pi), _sage_const_3 ))

